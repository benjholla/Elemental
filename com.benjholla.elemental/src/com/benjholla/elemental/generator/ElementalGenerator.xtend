/*
 * generated by Xtext 2.16.0
 */
package com.benjholla.elemental.generator

import com.benjholla.elemental.elemental.Assignment
import com.benjholla.elemental.elemental.Branch
import com.benjholla.elemental.elemental.ComputedGOTO
import com.benjholla.elemental.elemental.Decrement
import com.benjholla.elemental.elemental.DynamicDispatch
import com.benjholla.elemental.elemental.GOTO
import com.benjholla.elemental.elemental.Increment
import com.benjholla.elemental.elemental.Instruction
import com.benjholla.elemental.elemental.Label
import com.benjholla.elemental.elemental.Loop
import com.benjholla.elemental.elemental.Program
import com.benjholla.elemental.elemental.MoveLeft
import com.benjholla.elemental.elemental.MoveRight
import com.benjholla.elemental.elemental.Recall
import com.benjholla.elemental.elemental.StaticDispatch
import com.benjholla.elemental.elemental.Store
import java.io.File
import java.net.URI
import org.eclipse.core.filesystem.EFS
import org.eclipse.core.resources.IFile
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.CoreException
import org.eclipse.core.runtime.NullProgressMonitor
import org.eclipse.core.runtime.Path
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ElementalGenerator extends AbstractGenerator {

	val EXTENSION = ".e";

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (Program model : resource.allContents.toIterable.filter(Program)) {
			if (model.eResource.URI.isPlatform) {
			  val relativePath = model.eResource.URI.toPlatformString(true);
			  val platformRoot = ResourcesPlugin.getWorkspace().getRoot();
			  val iFile = platformRoot.getFile(new Path(relativePath));
			  val projectRoot = iFile.getProject().getFolder("/src").getLocation().toFile();
			  val modelFile = getFile(iFile);
			  val name = modelFile.getName().substring(0,modelFile.getName().length()-EXTENSION.length());
			  val namespaceDirectoryPath = modelFile.getParentFile().getAbsolutePath();
			  var namespace = namespaceDirectoryPath.substring(projectRoot.getAbsolutePath().length()).replace(File.separator, ".");
			  if(namespace.startsWith(".")){
			  	namespace = namespace.substring(1);
			  }
			  fsa.generateFile(namespace.replace(".", File.separator) + File.separator + name + ".java", compile(namespace, name, model));
			} else {
			  throw new RuntimeException("Unsupported platform!")
			}
		}
	}
	
	def String compile(String namespace, String name, Program model) {
		var pkg = "";
		if(!namespace.isEmpty()){
			pkg = "package " + namespace + ";\n\n";
		}
		return  pkg + '''
		import com.benjholla.elemental.runtime.ProgramFactory;
		import com.benjholla.elemental.runtime.Program;
		
		
		public class «name» {
			public static void main(String[] args){
				
				ProgramFactory factory = new ProgramFactory(System.in, System.out);
				
				«IF model.implicitFunction !== null && !model.implicitFunction.instructions.isEmpty»
				factory.beginFunction((byte) 0x00);
				«FOR instruction : model.implicitFunction.instructions»
				«compileInstruction(instruction)»
				«ENDFOR»
				factory.endFunction();
				
		        «ENDIF»
		        «FOR function : model.explicitFunctions»
		        factory.beginFunction((byte) 0x«String.format("%02X", Integer.parseInt(function.name))»);
		        «FOR instruction : function.body.instructions»
		        «compileInstruction(instruction)»
		        «ENDFOR»
		        factory.endFunction();
		        
		        «ENDFOR»
				Program program = factory.create();
				program.execute();
			}
			
		}
		''';
	}
	
	def String compileInstruction(Instruction instruction) {
		if(instruction.type instanceof Increment){
			return "factory.addIncrement();";
		} else if(instruction.type instanceof Decrement){
			return "factory.addDecrement();";
		} else if(instruction.type instanceof MoveLeft){
			return "factory.addMoveLeft();";
		} else if(instruction.type instanceof MoveRight){
			return "factory.addMoveRight();";
		} else if(instruction.type instanceof Store){
			return "factory.addStore();";
		} else if(instruction.type instanceof Recall){
			return "factory.addRecall();";
		} else if(instruction.type instanceof Assignment){
			return "factory.addAssignment();";
		} else if(instruction.type instanceof Branch){
			val branch = instruction.type as Branch;
			val result = new StringBuilder();
			result.append("factory.beginBranch();");
			for(Instruction bodyInstruction : branch.body.instructions){
				result.append("\n" + compileInstruction(bodyInstruction));
			}
			result.append("\n" + "factory.endBranch();");
			return result.toString();
		} else if(instruction.type instanceof Loop){
			val loop = instruction.type as Loop;
			val result = new StringBuilder();
			result.append("factory.beginLoop();");
			for(Instruction bodyInstruction : loop.body.instructions){
				result.append("\n" +  compileInstruction(bodyInstruction));
			}
			result.append("\n" + "factory.endLoop();");
			return result.toString();
		} else if(instruction.type instanceof Label){
			val label = instruction.type as Label;
			return "factory.addLabel((byte) 0x" + String.format("%02X", Integer.parseInt(label.name)) + ");";
		} else if(instruction.type instanceof GOTO){
			val GOTO = instruction.type as GOTO;
			return "factory.addGOTO((byte) 0x" + String.format("%02X", Integer.parseInt(GOTO.label.name)) + ");";
		} else if(instruction.type instanceof ComputedGOTO){
			return "factory.addComputedGOTO();";
		} else if(instruction.type instanceof StaticDispatch){
			val staticDispatch = instruction.type as StaticDispatch;
			return "factory.addStaticDispatch((byte) 0x" + String.format("%02X", Integer.parseInt(staticDispatch.target.name)) + ");";
		} else if(instruction.type instanceof DynamicDispatch){
			return "factory.addDynamicDispatch();";
		} else {
			return "// unknown instruction type (" + instruction.type.class.getSimpleName() + ")";
		}
	}
	
	/**
	 * Converts an IFile to a Java File
	 * 
	 * @param file
	 * @return
	 * @throws CoreException 
	 */
	def private static File getFile(IFile iFile) throws CoreException {
	  var uri = null as URI; 
	
	  // get the file uri, account for symbolic links
	  if(!iFile.isLinked()){
	    uri = iFile.getLocationURI();
	  } else {
	    uri = iFile.getRawLocationURI();
	  }
	
	  // get the native file using Eclipse File System
	  var file = null as File;
	  if(uri !== null){
	    file = EFS.getStore(uri).toLocalFile(0, new NullProgressMonitor());
	  } else {
	    // Eclipse is weird...this last resort should work
	    file = new File(iFile.getFullPath().toOSString());
	  }
	  
	  return file;
	}
}
